
#' QC on genes available in each study
#'
#' Calculate total number of genes per study, number of studies covering each
#' gene and numbers of overlapping genes in each pair of studies.
#'
#' @param res.studies [list] study specific
#' results (as generated by \code{\link{load_study_results}}.
#' @param group [character(n) or numeric(n)] groups which should be used for
#' stratification in boxplot (e.g. information about technology per study)
#'
#' @return data.frame with gene level statistics for each study:
#' \itemize{
#' \item id = unique study identifier
#' \item number.genes = total number of genes
#' \item median.overlapping.genes = median number of overlapping genes with
#' other studies
#' \item median.overlapping.genes.outlier = outlier based on
#' median.overlapping.genes (1: yes, 0: no, NA: not calculated due to small
#' number of studies)
#' }
#'
#' @export
qc_genes <- function(res.studies,
                     group = NULL) {

  if (!is.null(group) && length(group) != length(res.studies)) {
      stop("group information needs to be given for each study")
  }

  ## number of genes per study
  genes.l = lapply(res.studies, function(x) {
    x$gene
  })
  no.genes = sapply(genes.l, length)
  k = length(genes.l)

  g.no = my_boxplot(values = no.genes,
                    group = group,
                    title = "Total number of genes",
                    ylab = "number of genes")

  ## number of studies for each gene
  freq.genes = table(unlist(genes.l))
  tab = table(factor(freq.genes, levels = seq_len(k)))
  dat = data.frame(no.studies = names(tab),
                   freq = as.numeric(tab))
  g.cov = ggpubr::ggbarplot(
      dat,
      x = "no.studies",
      y = "freq",
      fill = "lightgray",
      xlab = "number of studies",
      ylab = "absolute frequency",
      title = "Coverage of genes") +
      ggplot2::theme_bw()

  ## number of overlapping genes
  overlap = matrix(0, nrow = k, ncol = k,
                   dimnames = list(names(genes.l),
                                   names(genes.l)))
  for (i in 1:(k - 1)) {
    for (j in (i + 1):k) {
      overlap[i, j] = overlap[j, i] =
        length(intersect(genes.l[[i]], genes.l[[j]]))
    }
  }
  med.overlap = apply(overlap, 1, stats::median, na.rm = TRUE)
  diag(overlap) = no.genes
  h = my_heatmap(matrix = overlap,
                 title = "Overlapping genes",
                 name = "number",
                 type = "other")

  ## plots
 g = cowplot::ggdraw() +
   cowplot::draw_plot(g.no, x = 0, y = 0.7, width = 0.3, height = 0.3) +
   cowplot::draw_plot(g.cov, x = 0.3, y = 0.7, width = 0.7, height = 0.3) +
   cowplot::draw_plot(
     grid::grid.grabExpr(ComplexHeatmap::draw(h)),
     x = 0.25, y = 0, width = 0.7,
     height = 0.7)
 print(g)

  ## statistics
  stats = data.frame(id = names(res.studies),
                     number.genes = no.genes,
                     median.overlapping.genes = med.overlap,
                     median.overlapping.genes.outlier =
                       get_outlier_info(values = med.overlap),
                     stringsAsFactors = FALSE)

  return(stats)
}


#' QC on estimates
#'
#' Calculate correlation of estimates in each pair of studies
#' based on overlapping genes.
#'
#' @param res.studies [list] study specific
#' results (as generated by \code{\link{load_study_results}}.
#' @param all [logical(1)] should all genes be plotted? If FALSE, only 
#' genes with nominal P-value < 0.05 are used. (default: FALSE).
#'
#' @return data.frame with gene level statistics for each study:
#' \itemize{
#' \item id = unique study identifier
#' \item median.cor.estimate = median number of correlation of estimates with
#' other studies
#' \item median.cor.estimate.outlier = outlier based on
#' median.cor.estimate (1: yes, 0: no, NA: not calculated due to small
#' number of studies)
#' }
#'
#' @export

qc_estimate <- function(res.studies, all = FALSE) {

  ## keep only genes with nominal P-value < 0.05
  if (!all) {
    res.studies = lapply(res.studies, function(x) {
      x[which(x$pvalue < 0.05), ]})
    n = sapply(res.studies, length)
    if (any(n == 0)) {
      stop(paste("study", 
                 paste(names(n), collapse = ", "), 
                 "has no nominally significant genes!"))
    }
  }
  qc_cor(res.studies = res.studies,
         column = "estimate",
         title = "Estimate")
}

#' QC on P-values
#'
#' Histogram of all P-values for each study.
#'
#' @param res.studies [list] study specific
#' results (as generated by \code{\link{load_study_results}}.
#'
#' @export

qc_pvalues <- function(res.studies) {
  
  pval.l = lapply(res.studies, function(x) {
    x$pvalue})
  dat = data.frame(
    pvalue = do.call("c", pval.l),
    study = rep(names(res.studies),
                sapply(pval.l, length)))
  g = ggpubr::gghistogram(dat,
                          x = "pvalue",
                          facet.by = "study",
                          fill = "lightgray")
  print(g)
}


#' QC on genes differentially expressed in each study
#'
#' Differentially expressed genes in each study are determined based on
#' adjusted P values < 0.05. Calculate total number of differentially expressed
#' (DE) genes per study, frequency of DE genes that are upregulated and number
#' of studies covering each DE gene (not taking into account direction of
#' effect) and numbers of overlapping DE and consistent genes in each pair of
#' studies.
#'
#' @param res.studies [list] Study specific
#' results (as generated by \code{\link{load_study_results}}.
#' @param group [character(n) or numeric(n)] groups which should be used for
#' stratification in boxplot (e.g. information about technology per study)
#'
#' @return data.frame with gene level statistics for each study:
#' \itemize{
#' \item id = unique study identifier
#' \item number.diff.expr.genes = number of DE genes
#' \item number.diff.expr.genes.outlier = outlier based on
#' number.diff.expr.genes (1: yes, 0: no, NA: not calculated due to small
#' number of studies)
#' \item freq.up.genes = relative frequency of DE genes that are upregulated
#' \item freq.up.genes.outlier = outlier based on
#' freq.up.genes (1: yes, 0: no, NA: not calculated due to small
#' number of studies)
#' \item median.overlapping.diff.expr.genes = median number of overlapping DE
#' and consistent genes with other studies
#' \item median.overlapping.diff.expr.genes.outlier = outlier based on
#' median.overlapping.diff.expr.genes (1: yes, 0: no, NA: not calculated due to small
#' number of studies)
#' }
#'
#' @export

qc_diff_expr_genes <- function(res.studies,
                               group = NULL) {

  res.studies.de = lapply(res.studies, function(x) {
    temp = x[which(x$pvalue.adj < 0.05), ]
    rownames(temp) = temp$gene
    return(temp)})
  k = length(res.studies.de)

  ## number of differentially expressed genes per study
  genes.de.l = lapply(res.studies.de, function(x) {
    x$gene})

  no.genes = sapply(genes.de.l, length)
  if (sum(no.genes > 0) > 2) {
    g.no = my_boxplot(values = no.genes,
                      group = group,
                      title = "Number of differentially expressed genes",
                      ylab = "number of genes")
    
    ## proportion of differentially expressed genes per study
    prop.genes = no.genes / sapply(res.studies, nrow)
    g.prop = my_boxplot(values = prop.genes,
                        group = group,
                        title = "Frequency of differentially expressed genes",
                        ylab = "relative frequency")
    
    ## proportion of upregulated differentially expressed genes per study
    no.genes.up = sapply(res.studies.de, function(x) {
      sum(x$estimate > 0)})
    prop.genes.up = no.genes.up / no.genes
    g.prop.up = my_boxplot(values = prop.genes.up,
                           group = group,
                           title = "Frequency of upregulated differentially expressed genes",
                           ylab = "relative frequency")
    
    ## number of studies for each gene
    freq.genes = table(unlist(genes.de.l))
    tab = table(factor(freq.genes, levels = seq_len(k)))
    dat = data.frame(no.studies = names(tab),
                     freq = as.numeric(tab))
    g.cov = ggpubr::ggbarplot(
      dat,
      x = "no.studies",
      y = "freq",
      fill = "lightgray",
      xlab = "number of studies",
      ylab = "absolute frequency",
      title = "Coverage of differentially expressed genes") +
      ggplot2::theme_bw()
    
    ## overlap
    overlap = matrix(0, nrow = k, ncol = k,
                     dimnames = list(names(res.studies.de),
                                     names(res.studies.de)))
    for (i in 1:(k - 1)) {
      for (j in (i + 1):k) {
        genes.both = intersect(genes.de.l[[i]],
                               genes.de.l[[j]])
        if (length(genes.both) > 0) {
          overlap[i, j] = overlap[j, i] =
            sum(sign(res.studies.de[[i]][genes.both, "estimate"]) ==
                  sign(res.studies.de[[j]][genes.both, "estimate"]),
                na.rm = TRUE)
        }
      }
    }
    med.overlap = apply(overlap, 1, stats::median, na.rm = TRUE)
    diag(overlap) = no.genes
    
#    ## remove studies with no differentially expressed genes
#    ind = which(no.genes == 0)
#    if (length(ind) > 0) {
#      overlap = overlap[-ind, -ind]
#    }
    
    h = my_heatmap(matrix = overlap,
                   title = "Overlapping differentially and consistent genes",
                   name = "number",
                   type = "other")
    
    ## plots
    # g = ggdraw() +
    #     draw_plot(g.no, x = 0, y = 0, width = 0.3, height = 1) +
    #     draw_plot(g.cov, x = 0.3, y = 0, width = 0.7, height = 1)
    g = cowplot::ggdraw() +
      cowplot::draw_plot(g.no, x = 0, y = 0.75, width = 0.5, height = 0.25) +
      cowplot::draw_plot(g.prop.up, x = 0.5, y = 0.75, width = 0.5, height = 0.25) +
      cowplot::draw_plot(g.cov, x = 0, y = 0.5, width = 1, height = 0.25) +
      cowplot::draw_plot(
        grid::grid.grabExpr(ComplexHeatmap::draw(h)),
        x = 0.25, y = 0, width = 0.5, height = 0.5)
    print(g)
    
    ## statistics
    stats = data.frame(id = names(res.studies),
                       number.diff.expr.genes = no.genes,
                       number.diff.expr.genes.outlier =
                         get_outlier_info(values = no.genes),
                       freq.up.genes = prop.genes.up,
                       freq.up.genes.outlier =
                         get_outlier_info(values = prop.genes.up),
                       median.overlapping.genes = med.overlap,
                       median.overlapping.genes.outlier =
                         get_outlier_info(values = med.overlap),
                       stringsAsFactors = FALSE)
  } else {
    stats = data.frame(id = names(res.studies),
                       number.diff.expr.genes = no.genes,
                       stringsAsFactors = FALSE)
  }
  
  return(stats)
}


#' @keywords internal
qc_cor <- function(res.studies,
                   column,
                   title,
                   cor.method = "spearman") {

  ## correlation matrix
  cor = estimate_cor_matrix(res.studies = res.studies,
                            column = column,
                            cor.method = cor.method)

  med.cor = apply(cor, 1, stats::median, na.rm = TRUE)

  h = my_heatmap(matrix = cor,
                 title = title,
                 name = "correlation coefficient",
                 type = "cor")
  ComplexHeatmap::draw(h)

  ## statistics
  stats = data.frame(names(res.studies),
                     med.cor,
                     get_outlier_info(values = med.cor),
                     stringsAsFactors = FALSE)
  colnames(stats) = c("id",
                      paste0("median.cor.", column, c("", ".outlier")))
  return(stats)
}


#' @keywords internal
my_boxplot <- function(values,
                       group = NULL,
                       title = "",
                       ylab = "") {

  if (is.null(group)) {
    group = rep("all", length(values))
  }
  dat = data.frame(values = values,
                   group = group)
  g = ggpubr::ggboxplot(
    dat,
    x = "group",
    y = "values",
    add = "dotplot",
    xlab = "",
    ylab = ylab,
    title = title) +
    ggplot2::theme_bw()

  return(g)
}

#' @keywords internal
my_heatmap <- function(matrix,
                       title = "",
                       name = "legend",
                       type = "cor") {

  if (type == "cor") {
    col = circlize::colorRamp2(c(-1, 0, 1), c("blue", "white", "red"))
  } else {
    col = RColorBrewer::brewer.pal(n = 9, name = "Blues")
  }
  h = ComplexHeatmap::Heatmap(
    matrix = matrix,
    name = name,
    column_title = title,
    col = col,
    rect_gp = grid::gpar(col = "grey"),
    column_names_rot = 45,
    row_names_gp = grid::gpar(fontsize = 8),
    column_names_gp = grid::gpar(fontsize = 8))
  return(h)

}


#' @keywords internal
get_outlier_info <- function(values,
                             min.number.studies = 3,
                             coef = 5) {

  if (length(values) >= min.number.studies) {
    med = stats::median(values, na.rm = TRUE)
    iqr = stats::IQR(values, na.rm = TRUE)
    th = c(med - coef * iqr, med + coef * iqr)
    out = as.numeric(values < th[1] | values > th[2])
  } else {
    out = rep(NA, length(values))
  }
  return(out)
}

#' internal function
#' @importFrom stats cor
#' @keywords internal

estimate_cor_matrix <- function(res.studies,
                                column,
                                cor.method = "spearman") {

  k = length(res.studies)
  res.studies = lapply(res.studies, function(x) {
    rownames(x) = x$gene
    return(x)
  })

  cor = matrix(nrow = k, ncol = k,
               dimnames = list(names(res.studies),
                               names(res.studies)))
  for (i in 1:(k - 1)) {
    for (j in (i + 1):k) {
      genes.both = intersect(res.studies[[i]]$gene,
                             res.studies[[j]]$gene)
      if (length(genes.both)  > 1) {
        cor[i, j] = cor[j, i] =
          stats::cor(res.studies[[i]][genes.both, column],
                     res.studies[[j]][genes.both, column],
                     use = "pairwise.complete.obs",
                     method = cor.method)
      }
    }
  }
  return(cor)
}

#' QC on number of differentially expressed genes depending on sample size
#'
#' Differentially expressed (DE) genes in each study are determined based on
#' adjusted P values < 0.05. For comparability only the number of 
#' DE genes among the genes available in each of the studies will be plotted
#' depending on the number of subjects.
#'
#' @param info.studies [data.frame] Information about studies (need to include
#' a column called "id" with a unique study identifier and a column 
#' "number.subjects" specifying the number of independent subjects in the study.
#' @param res.studies [list] Study specific
#' results (as generated by \code{\link{load_study_results}}.
#'
#' @return scatterplot as object of class \code{\link[ggplot2]{ggplot}} 
#' 
#' @export

plot_nr_de_genes <- function(info.studies, res.studies) {
  
  if (nrow(info.studies) != length(res.studies)) {
    stop("different number of studies!")
  }
  if (any(info.studies$id != names(res.studies))) {
    stop("different order of studies!")
  }
  
  genes.l = lapply(res.studies, function(x) {
    x$gene})
  tab = table(unlist(genes.l))
  common.genes = names(tab)[tab == length(res.studies)]
  if (length(common.genes) < 5000) {
    warning("less than 5000 common genes found")
  }
  
  number.de.genes = sapply(res.studies, function(x) {
    sum(x[common.genes, "pvalue.adj"] < 0.05)})
  
  info.res = data.frame(
    id = info.studies$id,
    number.subjects = info.studies$number.subjects,
    number.de.genes = number.de.genes,
    stringsAsFactors = FALSE)
  
  p = ggpubr::ggscatter(
    info.res,
    x = "number.subjects",
    y = "number.de.genes",
    label = "id",
    xlab = "number of subjects",
    ylab = "number of DE genes (based on common genes)")
  return(p)
  
}
