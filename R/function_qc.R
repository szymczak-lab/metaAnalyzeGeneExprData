
#' QC on genes available in each study
#'
#' Calculate total number of genes per study, number of studies covering each
#' gene and numbers of overlapping genes in each pair of studies.
#'
#' @param res.studies List with study specific
#' results (as generated by \code{\link{load_study_results}}.
#' @param group [character(n) or numeric(n)] groups which should be used for
#' stratification in boxplot (e.g. information about technology per study)
#'
#' @return data.frame with gene level statistics for each study:
#' \itemize{
#' \item id = unique study identifier
#' \item number.genes = total number of genes
#' \item median.overlapping.genes = median number of overlapping genes with
#' other studies
#' \item median.overlapping.genes.outlier = outlier based on
#' median.overlapping.genes (1: yes, 0: no, NA: not calculated due to small
#' number of studies)
#' }
#'
#' @importFrom cowplot ggdraw draw_plot
#' @export

qc_genes <- function(res.studies,
                     group = NULL) {

  if (!is.null(group) && length(group) != length(res.studies)) {
      stop("group information needs to be given for each study")
  }

  ## number of genes per study
  genes.l = lapply(res.studies, function(x) {
    x$gene
  })
  no.genes = sapply(genes.l, length)
  k = length(genes.l)

  g.no = my_boxplot(values = no.genes,
                    group = group,
                    title = "Total number of genes",
                    ylab = "number of genes")

  ## number of studies for each gene
  freq.genes = table(unlist(genes.l))
  tab = table(factor(freq.genes, levels = seq_len(k)))
  dat = data.frame(no.studies = names(tab),
                   freq = as.numeric(tab))
  g.cov = ggpubr::ggbarplot(
      dat,
      x = "no.studies",
      y = "freq",
      fill = "lightgray",
      xlab = "number of studies",
      ylab = "absolute frequency",
      title = "Coverage of genes") +
      ggplot2::theme_bw()

  ## number of overlapping genes
  overlap = matrix(nrow = k, ncol = k,
                   dimnames = list(names(genes.l),
                                   names(genes.l)))
  for (i in 1:(k - 1)) {
    for (j in (i + 1):k) {
      overlap[i, j] = overlap[j, i] =
        length(intersect(genes.l[[i]], genes.l[[j]]))
    }
  }
  med.overlap = apply(overlap, 1, stats::median, na.rm = TRUE)
  diag(overlap) = no.genes
  h = my_heatmap(matrix = overlap,
                 title = "Overlapping genes",
                 name = "number",
                 type = "other")

  ## plots
 g = cowplot::ggdraw() +
   cowplot::draw_plot(g.no, x = 0, y = 0.7, width = 0.3, height = 0.3) +
   cowplot::draw_plot(g.cov, x = 0.3, y = 0.7, width = 0.7, height = 0.3) +
   cowplot::draw_plot(
     grid::grid.grabExpr(ComplexHeatmap::draw(h)),
     x = 0.25, y = 0, width = 0.7,
     height = 0.7)
 print(g)

  ## statistics
  stats = data.frame(id = names(res.studies),
                     number.genes = no.genes,
                     median.overlapping.genes = med.overlap,
                     median.overlapping.genes.outlier =
                       get_outlier_info(values = med.overlap),
                     stringsAsFactors = FALSE)

  return(stats)
}




#' @keywords internal
my_boxplot <- function(values,
                       group = NULL,
                       title = "",
                       ylab = "") {

  if (is.null(group)) {
    group = rep("all", length(values))
  }
  dat = data.frame(values = values,
                   group = group)
  g = ggpubr::ggboxplot(
    dat,
    x = "group",
    y = "values",
    add = "dotplot",
    xlab = "",
    ylab = ylab,
    title = title) +
    ggplot2::theme_bw()

  return(g)
}

#' @keywords internal
my_heatmap <- function(matrix,
                       title = "",
                       name = "legend",
                       type = "cor") {

  if (type == "cor") {
    col = circlize::colorRamp2(c(-1, 0, 1), c("blue", "white", "red"))
  } else {
    col = RColorBrewer::brewer.pal(n = 9, name = "Blues")
  }
  h = ComplexHeatmap::Heatmap(
    matrix = matrix,
    name = name,
    column_title = title,
    col = col,
    rect_gp = grid::gpar(col = "grey"),
    column_names_rot = 45,
    row_names_gp = grid::gpar(fontsize = 8),
    column_names_gp = grid::gpar(fontsize = 8))
  return(h)

}


#' @keywords internal
get_outlier_info <- function(values,
                             min.number.studies = 3,
                             coef = 5) {

  if (length(values) >= min.number.studies) {
    med = stats::median(values, na.rm = TRUE)
    iqr = stats::IQR(values, na.rm = TRUE)
    th = c(med - coef * iqr, med + coef * iqr)
    out = as.numeric(values < th[1] | values > th[2])
  } else {
    out = rep(NA, length(values))
  }
  return(out)
}
